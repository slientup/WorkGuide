# 深入剖析Kubernetes
容器技术兴起源于Paas技术的普及，
docker公司发布的docker项目具有里程碑的意义，
docker项目通过容器镜像，解决了**应用打包**这个根本性难题
容器本身没有价值，有价值的是**容器编排**，容器技术生态爆发了一场关于容器编排的战争，最终以kubernetes项目和CNCF社区的胜利而告终。


## 容器技术概念入门篇

### 从进程说开去

沙盒技术：
沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术，这样，应用与应用之间，就因为有了**边界而不至于相互干扰**；而被装进集装箱的应用，
也可以**被方便地搬来搬去**，这不就是 PaaS 最理想的状态嘛。

首先，操作系统从“程序”中发现输入数据保存在一个文件中，所以这些数据就会被加载到内存中待命。同时，操作系统又读取到了计算加法的指令，
这时，它就需要指示 CPU 完成加法操作。而 CPU 与内存协作进行加法计算，又会使用寄存器存放数值、内存堆栈保存执行的命令和变量。
同时，计算机里还有被打开的文件，以及各种各样的 I/O 设备在不断地调用中修改自己的状态。
就这样，一旦“程序”被执行起来，它就**从磁盘上的二进制文件**，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的
状态信息的一个集合。**像这样一个程序运行起来后的计算机执行环境的总和，就是我们今天的主角：进程**


对于进程来说，它的静态表现就是程序，平常都是安安静静地待在磁盘上，而一旦运行起来，它就变成了计算机里的**数据和状态**总和，这就是它的动态表现。


容器技术的**核心功能**:通过约束和修改进程的动态表现，从而为其创造出一个**边界**

而`docker`主要通过`cgroups`技术和`namespace`技术来实现，其中`Cgroups`技术是用来制造约束的主要手段,`Namespace`技术则是用来修改进程视图的主要方法

```linux
$ docker run -it busybox /bin/sh
请帮我启动一个容器，在容器里执行 /bin/sh，并且给我分配一个命令行终端跟这个容器交互
/ # ps
PID  USER   TIME COMMAND
  1 root   0:00 /bin/sh
  10 root   0:00 ps
```
从上面信息我们可以看到docker容器最开始执行进程是`/bin/sh` 即第1号进程(PID=1),  它究竟是怎么做到的啦？
当我们在宿主机中运行`/bin/sh`的时候，操作系统会为它分配一个进程编号，比如PID=100，这个编号是进程的唯一标识，而`docker`会做障眼法，让`pid=100`看不到
之前的99个PID进程，让它误以为自己是1号进程

linux是怎么做到的啦？这就是**Namespace机制** 
```linux
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
```
当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数,新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，
它的 PID 是 1

而除了我们刚刚用到的 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行“障眼法”操作。
比如，`Mount Namespace`，用于让被隔离进程只看到当前 Namespace 里的挂载点信息；`Network Namespace`，用于让被隔离进程看到当前 `Namespace` 里的网络设备和配置.

**结论：** 容器，其实是一种特殊的进程而已
![容器](https://static001.geekbang.org/resource/image/d1/96/d1bb34cda8744514ba4c233435bf4e96.jpg)

### 隔离与限制
`Namespace`技术实际上修改了应用进程看待整个计算机“视图”，即它的“视线”被操作系统做了限制，只能“看到”某些`指定的内容`.
`docker`容器本身只是一个特殊的进程，它不占用性能损耗，所以在paas上面进行更细粒度的管理平台上大行其道，但因为是一个`特殊的进程`，所以最主要的问题
是**隔离得不彻底**

**首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核**

**其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间**

如果你的容器中的程序使用 settimeofday(2) 系统调用修改了时间，整个宿主机的时间都会被随之修改，这显然不符合用户的预期，所以"什么能做，什么不能做"就
必须考虑下。

**我们会遇到这么一个问题？**

虽然容器内的第 `1`号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 `100` 号进程与其他所有进程之间依然是**平等的竞争关系。**
这就意味着，虽然第`100`号进程表面上被隔离了起来，但是它所能够使用到的**资源（比如 CPU、内存）**，却是可以随时被宿主机上的其他进程（或者其他容器）占用的。
当然，这个`100`号进程自己也可能把**所有资源吃光**。这些情况，显然都不是一个“沙盒”应该表现出来的合理行为.

而 **Linux Cgroups (Linux Control Group) 就是 Linux 内核中用来为进程设置资源限制的一个重要功能** 就能解决这个问题，它主要的作用,就是限制一个进程组能够使用的资源上限，包括
`cpu 内存 磁盘 网络带宽`等等

通过`/sys/fs/cgroup`下面 cpuset、cpu、 memory 的子目录等信息分别对不同资源进行限制

比如 需要对cpu资源做限制
`cfs_period` 和 `cfs_quota` 这样的关键词。这两个参数需要组合使用，可以用来限制进程在长度为 `cfs_period` 的一段时间内，只能被分配到
总量为 `cfs_quota` 的 CPU 时间.

```linux
我们可以通过查看 container 目录下的文件，看到 container 控制组里的 `CPU quota` 还没有任何限制（即：-1），`CPU period` 则是默认的 100  ms（100000  us）

$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us 
-1
$ cat /sys/fs/cgroup/cpu/container/cpu.cfs_period_us 
100000

我们可以做一个限制 比如向 container 组里的 cfs_quota 文件写入 20 ms（20000 us）
echo 20000 > /sys/fs/cgroup/cpu/container/cpu.cfs_quota_us
```
它意味着在每 `100ms`的时间里，被该控制组限制的进程只能使用 `20ms` 的 CPU 时间，也就是说这个进程只能使用到 `20%` 的 CPU 带宽

docker中启动cpu限制
```
$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash
```

一个正在运行的 Docker 容器，其实就是一个启用了**多个 Linux Namespace 的应用进程**，而这个进程能够使用的资源量，则受`Cgroups`配置的限制

**容器是一个单进程模型**

 但实际中，跟Namespace 的情况类似，`Cgroups`对资源的限制能力也有很多不完善的地方，被提及最多的自然是`/proc`文件系统的问题
 
 比如：你如果在容器里执行 top 指令，就会发现，它显示的信息居然是宿主机的CPU 和内存数据，而不是当前容器的数据.?Linux 下的 /proc 目录存储的是记录当前内核运行状态的一系列特殊文件，用户可以通过访问这些文件，查看系统以及当前正在运行的进程的信息，比如
 CPU 使用情况、内存占用率等，这些文件也是 top 指令查看系统信息的主要数据来源。/proc 文件系统并不知道用户通过 Cgroups 给这个容器做了什么样的资源限制，即：/proc 文件系统不了解 Cgroups 限制的存在
 









































