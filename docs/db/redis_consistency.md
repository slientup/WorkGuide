# redis缓存与数据库的一致性问题分析
参考链接：https://blog.csdn.net/diweikang/article/details/94406186

### 缓存可能带来的问题
#### 缓存击穿
大量的请求同时查询**同一个key**时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿
解决思路：将大量请求限制在少量请求上，将大变小
解决方案：采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有





#### redis缓存与数据库一致性的问题
理论上讲给缓存设置过期时间，是保证最终一致性的解决方案。但接下来的方案是不依赖于给缓存设置时间的方案；  
三种更新策略:  
- 先更新数据库，再更新缓存
- 先删除缓存，再更新数据库
- 先更新数据库，再删除缓存  
- 缓存失败，设置补偿机制  
##### 方案一 先更新数据库，再更新缓存  
这种方案从业务角度来说并不好，比如你的场景可能是写入比较多，而实际使用读比较少，这种方案就会导致性能浪费；   
这种方式也会存在线程安全的问题 比如同时有请求A和请求B进行更新操作，那么会出现  
（1）线程A更新了数据库  
（2）线程B更新了数据库  
（3）线程B更新了缓存  
（4）线程A更新了缓存  
这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。  

##### 方案二 先删除缓存，再更新数据库
数据不一致场景：   
同时有一个请求A进行更新操作，另一个请求B进行查询操作   
（1）请求A进行写操作，删除缓存   
（2）请求B查询发现缓存不存在    
（3）请求B去数据库查询得到旧值     
（4）请求B将旧值写入缓存   
（5）请求A将新值写入数据库   
解决思路:采用延时双删策略  
```
伪代码如下：
public void write(String key,Object data){
 
    redis.delKey(key);
    db.updateData(data);
 
    Thread.sleep(1000);
    redis.delKey(key);
```
##### 方案三 先更新数据库，再删缓存的策略
不一致的场景:假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作  
（1）缓存刚好失效  
（2）请求A查询数据库，得一个旧值  
（3）请求B将新值写入数据库  
（4）请求B删除缓存  
（5）请求A将查到的旧值写入缓存。  
但发生这件事的概率是非常非常低，它要求步骤3写入数据库的速度要比2请求的速度都要快，这种显然概率是非常非常低的  

##### 如何删除缓存失败的话，有什么补偿机制吗？ 核心思想就是将删除失败的key放入到消息队列中，做重试机制
处理流程如下：  
（1）更新数据库数据；  
（2）缓存因为种种问题删除失败  
（3）将需要删除的key发送至消息队列 
（4）自己消费消息，获得需要删除的key    
（5）继续重试删除操作，直到成功    
![处理流程](https://img-blog.csdnimg.cn/20190701203347688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rpd2Vpa2FuZw==,size_16,color_FFFFFF,t_70)



